# üîÆ M1.1 "Polish" - Plano de A√ß√£o Detalhado

**Data de Cria√ß√£o:** 03/11/2025  
**Branch:** `feature/m1.1-polish`  
**Status Geral:** 0% - Planejamento Inicial  
**Tempo Estimado Total:** 20-25 horas  
**Vers√£o Target:** v0.3.0

---

## üéØ Objetivos do M1.1

Transformar o editor Lumy de **funcional** para **profissional** atrav√©s de:

1. **Performance:** Renderiza√ß√£o OpenGL moderna para mapas grandes (100x100 tiles) mantendo 60 FPS
2. **Usabilidade:** Ferramentas visuais avan√ßadas (colis√£o overlay, zoom suave)
3. **Produtividade:** Hot-reload para ver mudan√ßas instantaneamente no runtime
4. **Qualidade:** PropertyGrid din√¢mico robusto e documenta√ß√£o completa

---

## üìã Definition of Done (DoD)

- [ ] Editor mant√©m **60 FPS** com mapas 100x100 tiles com todas as layers vis√≠veis
- [ ] Hot-reload funcional - mudan√ßas no editor aparecem no hello-town em < 1 segundo
- [ ] Overlay de colis√£o com toggle visual (F4) e opacidade configur√°vel
- [ ] Zoom/Pan com transi√ß√µes suaves e limites inteligentes (0.25x - 4.0x)
- [ ] PropertyGrid din√¢mico suporta todos os tipos de propriedades de tiles/layers/mapas
- [ ] Tutorial b√°sico de 10 minutos (texto + screenshots) em `docs/tutorials/`
- [ ] Todos os testes unit√°rios passando com cobertura m√≠nima de 80%
- [ ] Build limpo sem warnings em MSVC Debug e Release

---

## üóÇÔ∏è Estrutura de Implementa√ß√£o

### **Fase 1: Performance Core - OpenGL Moderna** ‚ö°
**Prioridade:** CR√çTICA  
**Tempo Estimado:** 8-10 horas  
**Status:** üî¥ Not Started

#### **1.1 Refatora√ß√£o ViewportPanel para OpenGL Moderno**
**Tempo:** 4-5h | **Arquivos:** `viewport_panel.h/cpp`

**Estado Atual:**
- `ViewportPanel::GLCanvas` j√° existe e herda de `wxGLCanvas` ‚úÖ
- OpenGL immediate mode (glBegin/glEnd) est√° em uso
- Renderiza√ß√£o funcional mas n√£o otimizada para mapas grandes

**Tarefas:**

- [ ] **1.1.1** Criar estrutura de dados para Vertex Buffer Objects (VBOs)
  ```cpp
  struct TileVertex {
      float x, y, z;        // Posi√ß√£o
      float u, v;           // Coordenadas de textura
      float r, g, b, a;     // Cor/opacidade da layer
  };
  ```
  - Criar `GLBuffer` helper class para gerenciar VBOs
  - Implementar double-buffering para upload de dados
  - **Arquivo:** `editor/gl_buffer.h/cpp` (novo)
  - **Tempo:** 1.5h

- [ ] **1.1.2** Sistema de Texture Atlas para Tilesets
  ```cpp
  class TextureAtlas {
      GLuint m_textureId;
      std::unordered_map<int, wxRect> m_tileUVs;
  public:
      void LoadTileset(const wxString& path, int tileWidth, int tileHeight);
      wxRect GetTileUV(int tileId) const;
      void Bind() const;
  };
  ```
  - Carregar tilesets como texturas OpenGL
  - Calcular UVs automaticamente baseado no grid
  - Cache de texturas por tileset
  - **Arquivo:** `editor/texture_atlas.h/cpp` (novo)
  - **Tempo:** 2h

- [ ] **1.1.3** Implementar Batch Rendering
  ```cpp
  class MapRenderer {
      std::vector<TileVertex> m_vertices;
      GLBuffer m_vbo;
      TextureAtlas* m_atlas;
  public:
      void BuildMesh(const Map* map, int layerIndex);
      void Render(const glm::mat4& viewProj);
  };
  ```
  - Gerar mesh completa da layer em um √∫nico draw call
  - Suportar m√∫ltiplas layers com diferentes opacidades
  - Implementar frustum culling b√°sico (s√≥ renderizar tiles vis√≠veis)
  - **Arquivo:** `editor/map_renderer.h/cpp` (novo)
  - **Tempo:** 2-2.5h

- [ ] **1.1.4** Shaders Simples para Tiles
  ```glsl
  // vertex.glsl
  #version 330 core
  layout(location = 0) in vec3 aPos;
  layout(location = 1) in vec2 aTexCoord;
  layout(location = 2) in vec4 aColor;
  
  uniform mat4 uViewProj;
  out vec2 vTexCoord;
  out vec4 vColor;
  
  void main() {
      gl_Position = uViewProj * vec4(aPos, 1.0);
      vTexCoord = aTexCoord;
      vColor = aColor;
  }
  
  // fragment.glsl
  #version 330 core
  in vec2 vTexCoord;
  in vec4 vColor;
  out vec4 FragColor;
  
  uniform sampler2D uTexture;
  
  void main() {
      FragColor = texture(uTexture, vTexCoord) * vColor;
  }
  ```
  - Criar sistema de carregamento de shaders
  - Shader b√°sico para tiles com textura + opacidade
  - Shader para grid (linhas s√≥lidas)
  - Shader para collision overlay (cor s√≥lida + alpha)
  - **Arquivo:** `editor/shaders/` (pasta nova) + `shader_program.h/cpp`
  - **Tempo:** 2h

**Entreg√°veis:**
- ‚úÖ ViewportPanel renderiza mapas usando VBOs
- ‚úÖ M√∫ltiplas layers com opacidade renderizadas corretamente
- ‚úÖ Performance: 60 FPS com mapa 100x100 e 5 layers
- ‚úÖ Grid overlay renderizado com OpenGL (n√£o mais com immediate mode)

**Crit√©rios de Aceita√ß√£o:**
```cpp
// Benchmark de performance
Map* testMap = CreateTestMap(100, 100, 5); // 100x100 com 5 layers
for (int frame = 0; frame < 600; ++frame) { // 10 segundos @ 60 FPS
    m_viewport->RefreshMapDisplay();
    // FPS m√©dio deve ser >= 60
}
```

---

#### **1.2 Sistema de Grid Otimizado**
**Tempo:** 1h | **Arquivos:** `viewport_panel.cpp`, `shaders/grid.glsl`

**Tarefas:**
- [ ] **1.2.1** Renderizar grid usando line strips em vez de glBegin/glEnd
  - Criar VBO para linhas do grid
  - Shader espec√≠fico para linhas com anti-aliasing
  - Cache do grid (s√≥ reconstruir quando zoom/pan mudar muito)
  - **Tempo:** 0.5h

- [ ] **1.2.2** Grid adaptativo baseado no zoom
  ```cpp
  float GetGridSpacing() const {
      if (m_zoom < 0.5f) return 4.0f * TILE_SIZE; // Grid a cada 4 tiles
      if (m_zoom < 1.0f) return 2.0f * TILE_SIZE; // Grid a cada 2 tiles
      return TILE_SIZE; // Grid normal
  }
  ```
  - Reduzir densidade do grid em zoom out
  - Aumentar espessura das linhas em zoom in
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Grid renderizado com OpenGL moderno
- ‚úÖ Grid adaptativo n√£o afeta performance

---

### **Fase 2: Ferramentas Visuais Avan√ßadas** üé®
**Prioridade:** ALTA  
**Tempo Estimado:** 4-5 horas  
**Status:** üî¥ Not Started

#### **2.1 Visualiza√ß√£o de Colis√£o com Overlay**
**Tempo:** 2h | **Arquivos:** `viewport_panel.h/cpp`, `collision_overlay.h/cpp`

**Tarefas:**
- [ ] **2.1.1** Criar sistema de Collision Overlay
  ```cpp
  class CollisionOverlay {
      std::vector<wxRect> m_collisionRects; // Tiles com colis√£o
      GLBuffer m_vbo;
      float m_opacity; // 0.0 - 1.0
      wxColour m_color; // Cor do overlay (vermelho por padr√£o)
  public:
      void BuildFromMap(const Map* map, const TilesetManager* tilesets);
      void Render(const glm::mat4& viewProj);
      void SetOpacity(float opacity);
  };
  ```
  - Detectar tiles com propriedade de colis√£o do TilesetManager
  - Renderizar overlay transparente vermelho sobre tiles colid√≠veis
  - **Arquivo:** `editor/collision_overlay.h/cpp` (novo)
  - **Tempo:** 1h

- [ ] **2.1.2** Integrar com ViewportPanel
  - Adicionar toggle "Show Collision" (F4) no menu View
  - Adicionar slider de opacidade (0-100%) na toolbar
  - Atualizar overlay quando map ou tilesets mudarem
  - **Tempo:** 0.5h

- [ ] **2.1.3** UI para marcar colis√£o de tiles
  - Ferramenta "Collision Brush" (tecla 'C')
  - Click em tile para toggle colis√£o
  - Atualizar TilesetManager com propriedades
  - Salvar propriedades de colis√£o no projeto
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Overlay de colis√£o visual com toggle e opacidade
- ‚úÖ Ferramenta para marcar/desmarcar colis√£o de tiles
- ‚úÖ Propriedades de colis√£o salvas no projeto

---

#### **2.2 Zoom/Pan Avan√ßado com Transi√ß√µes Suaves**
**Tempo:** 2-3h | **Arquivos:** `viewport_panel.cpp`

**Estado Atual:**
- Zoom/Pan b√°sico funcional
- Sem limites ou transi√ß√µes suaves

**Tarefas:**
- [ ] **2.2.1** Implementar Smooth Zoom
  ```cpp
  class SmoothTransform {
      float m_currentZoom, m_targetZoom;
      float m_currentPanX, m_currentPanY;
      float m_targetPanX, m_targetPanY;
      wxTimer m_animTimer;
  public:
      void AnimateZoom(float targetZoom, float duration = 0.3f);
      void AnimatePan(float targetX, float targetY, float duration = 0.2f);
      void Update(float deltaTime); // Interpola√ß√£o lerp
  };
  ```
  - Interpola√ß√£o suave (ease-in-out) para zoom e pan
  - Mouse wheel para zoom incremental com anima√ß√£o
  - Zoom centrado no cursor do mouse
  - **Tempo:** 1.5h

- [ ] **2.2.2** Limites Inteligentes
  ```cpp
  struct ViewportBounds {
      float minZoom = 0.25f;
      float maxZoom = 4.0f;
      wxRect mapBounds;
      
      void ClampZoom(float& zoom);
      void ClampPan(float& panX, float& panY, float zoom, wxSize viewportSize);
  };
  ```
  - Limites de zoom: 0.25x (zoom out m√°ximo) at√© 4.0x (zoom in m√°ximo)
  - N√£o permitir pan al√©m dos limites do mapa
  - Ajustar limites de pan dinamicamente com o zoom
  - **Tempo:** 1h

- [ ] **2.2.3** Atalhos e Controles Aprimorados
  - **Scroll Wheel:** Zoom in/out
  - **Middle Mouse Drag:** Pan
  - **Ctrl + Scroll:** Zoom mais r√°pido
  - **Shift + Scroll:** Pan horizontal
  - **Espa√ßo + Drag:** Pan tempor√°rio (qualquer ferramenta)
  - **Ctrl + 0:** Reset zoom para 100%
  - **Ctrl + 1:** Fit map to viewport
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Zoom suave com anima√ß√£o
- ‚úÖ Pan com limites inteligentes
- ‚úÖ Zoom centrado no cursor
- ‚úÖ Atalhos intuitivos para navega√ß√£o

---

### **Fase 3: Hot-Reload com Runtime** üî•
**Prioridade:** ALTA  
**Tempo Estimado:** 4-5 horas  
**Status:** üî¥ Not Started

#### **3.1 Sistema de Comunica√ß√£o Editor-Runtime**
**Tempo:** 3-4h | **Arquivos:** `editor/hot_reload.h/cpp`, `src/hot_reload_client.h/cpp`

**Arquitetura:**
```
Editor (Servidor)           Runtime (Cliente)
     |                           |
     | --- Socket/Pipe -------> |
     | <----- ACK -------------- |
     |                           |
  Save Map               Receive Notification
     |                    Reload Map Data
     | --- MAP_CHANGED --> |
```

**Tarefas:**
- [ ] **3.1.1** Protocolo de Mensagens Simples
  ```cpp
  enum MessageType : uint8_t {
      MSG_MAP_CHANGED = 1,
      MSG_TILESET_CHANGED = 2,
      MSG_EVENT_CHANGED = 3,
      MSG_RELOAD_ALL = 4,
      MSG_ACK = 99
  };
  
  struct Message {
      MessageType type;
      uint32_t dataSize;
      char data[MAX_DATA_SIZE];
  };
  ```
  - Protocolo bin√°rio simples e r√°pido
  - Mensagens com tamanho vari√°vel
  - ACK para confirma√ß√£o de recebimento
  - **Arquivo:** `shared/hot_reload_protocol.h` (novo)
  - **Tempo:** 1h

- [ ] **3.1.2** Servidor Hot-Reload no Editor
  ```cpp
  class HotReloadServer {
      int m_socket; // ou HANDLE para named pipe no Windows
      std::thread m_listenerThread;
      std::vector<int> m_clients;
  public:
      bool Start(uint16_t port = 7777);
      void NotifyMapChanged(const wxString& mapPath);
      void NotifyTilesetChanged(const wxString& tilesetPath);
      void Stop();
  };
  ```
  - Socket TCP simples ou Named Pipe (Windows)
  - Aceitar m√∫ltiplas conex√µes (suportar m√∫ltiplos runtimes)
  - Enviar notifica√ß√µes broadcast para todos os clientes
  - **Arquivo:** `editor/hot_reload_server.h/cpp` (novo)
  - **Tempo:** 1.5-2h

- [ ] **3.1.3** Cliente Hot-Reload no Runtime
  ```cpp
  class HotReloadClient {
      int m_socket;
      std::thread m_receiverThread;
      std::atomic<bool> m_hasUpdate;
      wxString m_pendingMapPath;
  public:
      bool Connect(const wxString& host = "127.0.0.1", uint16_t port = 7777);
      bool HasPendingUpdate();
      wxString GetPendingMapPath();
      void Disconnect();
  };
  ```
  - Conectar ao editor no startup do runtime
  - Thread para receber mensagens ass√≠ncronas
  - Notificar MapScene sobre mudan√ßas
  - **Arquivo:** `src/hot_reload_client.h/cpp` (novo)
  - **Tempo:** 1-1.5h

- [ ] **3.1.4** Integra√ß√£o com Editor e Runtime
  - Editor: Iniciar servidor no startup, notificar em Save
  - Runtime: Conectar ao editor, recarregar mapa ao receber notifica√ß√£o
  - Adicionar op√ß√£o "Enable Hot-Reload" no menu Tools
  - Indicador visual no editor quando runtime est√° conectado
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Editor notifica runtime de mudan√ßas em < 100ms
- ‚úÖ Runtime recarrega mapa automaticamente ao salvar no editor
- ‚úÖ Suporte a m√∫ltiplos runtimes conectados simultaneamente
- ‚úÖ Tratamento de erros (desconex√£o, timeout)

---

#### **3.2 FileWatcher Aprimorado**
**Tempo:** 1h | **Arquivos:** `editor/file_watcher.h/cpp`

**Estado Atual:**
- FileWatcher b√°sico existe mas n√£o integrado com hot-reload

**Tarefas:**
- [ ] **3.2.1** Integrar FileWatcher com HotReloadServer
  - Detectar mudan√ßas externas em arquivos do projeto
  - Notificar runtime automaticamente
  - Debounce para evitar m√∫ltiplas notifica√ß√µes
  - **Tempo:** 0.5h

- [ ] **3.2.2** UI para Status do FileWatcher
  - Indicador na status bar: "Watching: 5 files"
  - Log de mudan√ßas detectadas
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Mudan√ßas externas detectadas e propagadas para runtime
- ‚úÖ UI mostra status do file watcher

---

### **Fase 4: PropertyGrid Din√¢mico Aprimorado** üéõÔ∏è
**Prioridade:** M√âDIA  
**Tempo Estimado:** 3-4 horas  
**Status:** üî¥ Not Started

#### **4.1 Sistema de Propriedades Robusto**
**Tempo:** 2-3h | **Arquivos:** `property_grid_panel.h/cpp`, `property_system.h/cpp`

**Estado Atual:**
- PropertyGrid b√°sico existe mas n√£o din√¢mico

**Tarefas:**
- [ ] **4.1.1** Sistema de Property Descriptors
  ```cpp
  struct PropertyDescriptor {
      wxString name;
      wxString category;
      PropertyType type; // INT, FLOAT, STRING, BOOL, COLOR, ENUM
      std::variant<int, float, wxString, bool, wxColour> value;
      std::function<void(const std::variant&)> setter;
      std::function<std::variant()> getter;
  };
  
  class PropertyCollection {
      std::vector<PropertyDescriptor> m_properties;
  public:
      void AddProperty(const PropertyDescriptor& prop);
      void PopulateGrid(wxPropertyGrid* grid);
      void OnPropertyChanged(wxPropertyGridEvent& event);
  };
  ```
  - Sistema gen√©rico de propriedades com getter/setter
  - Suporte a diferentes tipos: int, float, string, bool, color, enum
  - Valida√ß√£o de valores
  - **Arquivo:** `editor/property_system.h/cpp` (novo)
  - **Tempo:** 1.5h

- [ ] **4.1.2** Propriedades para Diferentes Contextos
  
  **Tile Properties:**
  ```cpp
  void PopulateTileProperties(int tileId, const TilesetManager* mgr) {
      AddProperty({"Tile ID", "Basic", INT, tileId, nullptr, nullptr});
      AddProperty({"Collision", "Physics", BOOL, hasCollision, setter, getter});
      AddProperty({"Terrain Tag", "Gameplay", ENUM, terrainType, setter, getter});
      AddProperty({"Passability", "Physics", FLAGS, directions, setter, getter});
  }
  ```
  
  **Layer Properties:**
  ```cpp
  void PopulateLayerProperties(Layer* layer) {
      AddProperty({"Name", "Basic", STRING, layer->GetName(), setter, getter});
      AddProperty({"Opacity", "Visual", FLOAT, layer->GetOpacity(), setter, getter});
      AddProperty({"Visible", "Visual", BOOL, layer->IsVisible(), setter, getter});
      AddProperty({"Locked", "Edit", BOOL, layer->IsLocked(), setter, getter});
      AddProperty({"Z-Order", "Basic", INT, layer->GetZOrder(), setter, getter});
  }
  ```
  
  **Map Properties:**
  ```cpp
  void PopulateMapProperties(Map* map) {
      AddProperty({"Name", "Basic", STRING, map->GetName(), setter, getter});
      AddProperty({"Width", "Size", INT, map->GetWidth(), nullptr, nullptr}); // Read-only
      AddProperty({"Height", "Size", INT, map->GetHeight(), nullptr, nullptr});
      AddProperty({"Tile Width", "Size", INT, map->GetTileWidth(), nullptr, nullptr});
      AddProperty({"Tile Height", "Size", INT, map->GetTileHeight(), nullptr, nullptr});
      AddProperty({"BGM", "Audio", STRING, map->GetBGM(), setter, getter});
      AddProperty({"Parallax", "Visual", STRING, map->GetParallax(), setter, getter});
  }
  ```
  - **Tempo:** 1-1.5h

- [ ] **4.1.3** Integra√ß√£o com Undo/Redo
  - Criar `ChangePropertyCommand` para altera√ß√µes de propriedades
  - Integrar com CommandHistory do ViewportPanel
  - Undo/Redo funciona para mudan√ßas no PropertyGrid
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ PropertyGrid mostra propriedades baseado na sele√ß√£o atual
- ‚úÖ Suporte a todos os tipos de propriedades necess√°rios
- ‚úÖ Mudan√ßas no PropertyGrid integradas com Undo/Redo
- ‚úÖ Valida√ß√£o de valores de propriedades

---

#### **4.2 UI Melhorada do PropertyGrid**
**Tempo:** 1h | **Arquivos:** `property_grid_panel.cpp`

**Tarefas:**
- [ ] **4.2.1** Categorias Colaps√°veis
  - Agrupar propriedades por categoria (Basic, Visual, Physics, etc.)
  - Salvar estado das categorias (expandido/colapsado)
  - **Tempo:** 0.5h

- [ ] **4.2.2** Custom Editors
  - Color picker para propriedades de cor
  - File picker para paths (BGM, Parallax, etc.)
  - Dropdown para enums
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ PropertyGrid organizado e intuitivo
- ‚úÖ Custom editors para tipos complexos

---

### **Fase 5: Documenta√ß√£o e Tutoriais** üìö
**Prioridade:** M√âDIA  
**Tempo Estimado:** 3-4 horas  
**Status:** üî¥ Not Started

#### **5.1 Tutorial B√°sico "Seu Primeiro Mapa"**
**Tempo:** 2-3h | **Arquivo:** `docs/tutorials/first_map.md`

**Conte√∫do:**
1. Introdu√ß√£o ao Editor Lumy
2. Criando um Novo Projeto
3. Adicionando um Tileset
4. Criando Layers e Pintando Tiles
5. Configurando Propriedades do Mapa
6. Testando com Hot-Reload
7. Adicionando Colis√£o
8. Salvando e Exportando

**Formato:**
- Texto claro e conciso (< 2000 palavras)
- Screenshots anotados a cada passo importante
- Dicas e atalhos ao longo do tutorial
- Tempo estimado: 10-15 minutos para completar

**Tarefas:**
- [ ] **5.1.1** Escrever o tutorial completo com screenshots
  - **Tempo:** 2h

- [ ] **5.1.2** Criar projeto de exemplo "first_map_tutorial"
  - Incluir tileset b√°sico
  - Mapa inicial vazio
  - **Tempo:** 0.5h

- [ ] **5.1.3** Revisar e testar o tutorial com usu√°rio externo
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Tutorial completo em `docs/tutorials/first_map.md`
- ‚úÖ Projeto de exemplo em `examples/first_map_tutorial/`

---

#### **5.2 Documenta√ß√£o de Atalhos e Ferramentas**
**Tempo:** 1h | **Arquivo:** `docs/SHORTCUTS.md`

**Conte√∫do:**
- Lista completa de atalhos de teclado
- Descri√ß√£o de todas as ferramentas
- Dicas de produtividade
- Troubleshooting comum

**Tarefas:**
- [ ] **5.2.1** Criar `docs/SHORTCUTS.md`
  - **Tempo:** 0.5h

- [ ] **5.2.2** Adicionar tooltip hints no editor para atalhos
  - Mostrar atalho ao lado do nome da ferramenta
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Documenta√ß√£o de atalhos completa
- ‚úÖ Tooltips no editor mostram atalhos

---

### **Fase 6: Testes e Polish Final** üß™
**Prioridade:** ALTA  
**Tempo Estimado:** 3-4 horas  
**Status:** üî¥ Not Started

#### **6.1 Testes de Performance**
**Tempo:** 1-2h | **Arquivo:** `tests/editor/performance_test.cpp`

**Tarefas:**
- [ ] **6.1.1** Benchmark de Renderiza√ß√£o
  ```cpp
  TEST_CASE("Viewport renders large map at 60 FPS") {
      Map* testMap = CreateTestMap(100, 100, 5);
      ViewportPanel viewport;
      viewport.SetCurrentMap(testMap);
      
      auto start = std::chrono::high_resolution_clock::now();
      int frameCount = 0;
      while (frameCount < 600) { // 10 segundos
          viewport.RefreshMapDisplay();
          frameCount++;
      }
      auto end = std::chrono::high_resolution_clock::now();
      
      float elapsedSeconds = std::chrono::duration<float>(end - start).count();
      float fps = frameCount / elapsedSeconds;
      
      REQUIRE(fps >= 60.0f);
  }
  ```
  - **Tempo:** 1h

- [ ] **6.1.2** Benchmark de Hot-Reload
  ```cpp
  TEST_CASE("Hot-reload latency is under 100ms") {
      HotReloadServer server;
      HotReloadClient client;
      
      server.Start();
      client.Connect();
      
      auto start = std::chrono::high_resolution_clock::now();
      server.NotifyMapChanged("test.tmx");
      
      while (!client.HasPendingUpdate()) {
          std::this_thread::sleep_for(std::chrono::milliseconds(1));
      }
      
      auto end = std::chrono::high_resolution_clock::now();
      auto latency = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
      
      REQUIRE(latency.count() < 100);
  }
  ```
  - **Tempo:** 1h

**Entreg√°veis:**
- ‚úÖ Testes de performance passando
- ‚úÖ Benchmarks documentados

---

#### **6.2 Testes de Integra√ß√£o**
**Tempo:** 1-2h | **Arquivo:** `tests/editor/integration_test.cpp`

**Tarefas:**
- [ ] **6.2.1** Teste de PropertyGrid ‚Üí Undo/Redo
  ```cpp
  TEST_CASE("PropertyGrid changes can be undone/redone") {
      Layer layer("Test Layer");
      PropertyGridPanel propGrid;
      CommandHistory cmdHistory;
      
      // Mudar opacidade via PropertyGrid
      propGrid.SetLayerOpacity(0.5f);
      REQUIRE(layer.GetOpacity() == 0.5f);
      
      // Undo
      cmdHistory.Undo();
      REQUIRE(layer.GetOpacity() == 1.0f);
      
      // Redo
      cmdHistory.Redo();
      REQUIRE(layer.GetOpacity() == 0.5f);
  }
  ```
  - **Tempo:** 0.5h

- [ ] **6.2.2** Teste de Collision Overlay Sync
  ```cpp
  TEST_CASE("Collision overlay updates when tileset changes") {
      Map map;
      TilesetManager tilesets;
      CollisionOverlay overlay;
      
      // Marcar tile como colid√≠vel
      tilesets.SetTileCollision(1, true);
      overlay.BuildFromMap(&map, &tilesets);
      
      REQUIRE(overlay.HasCollisionAt(0, 0));
  }
  ```
  - **Tempo:** 0.5h

- [ ] **6.2.3** Teste End-to-End: Editor ‚Üí Hot-Reload ‚Üí Runtime
  - Automatizar fluxo completo
  - **Tempo:** 1h

**Entreg√°veis:**
- ‚úÖ Testes de integra√ß√£o passando
- ‚úÖ Cobertura de c√≥digo >= 80%

---

#### **6.3 Polish e Bug Fixes**
**Tempo:** 1h | **Arquivos:** Diversos

**Tarefas:**
- [ ] **6.3.1** Build limpo sem warnings
  - Corrigir todos os warnings do MSVC
  - Habilitar `/W4` e tratar warnings como erros
  - **Tempo:** 0.5h

- [ ] **6.3.2** UI Polish
  - Verificar layout em diferentes resolu√ß√µes
  - Ajustar tooltips e labels
  - Consist√™ncia de √≠cones
  - **Tempo:** 0.5h

**Entreg√°veis:**
- ‚úÖ Build limpo (0 warnings)
- ‚úÖ UI polida e consistente

---

## üîß Comandos de Build e Teste

```bash
# Configurar (primeira vez ou ap√≥s mudan√ßas no CMakeLists.txt)
cmake --preset msvc-vcpkg

# Build Debug
cmake --build build/msvc --config Debug

# Build Release (para testes de performance)
cmake --build build/msvc --config Release

# Executar editor
build/msvc/bin/Debug/lumy-editor.exe

# Executar runtime para testar hot-reload
build/msvc/bin/Debug/hello-town.exe

# Rodar todos os testes
ctest -C Debug --test-dir build/msvc --output-on-failure

# Rodar testes de performance (Release)
ctest -C Release --test-dir build/msvc -R performance
```

---

## üìä M√©tricas de Progresso

| Feature                          | Status | % Completo | Tempo Gasto | Blocker? |
|----------------------------------|--------|------------|-------------|----------|
| OpenGL Moderno (VBOs/Shaders)    | üî¥ 0%  | 0%         | 0h / 8-10h  | ‚ö†Ô∏è Sim   |
| Grid Otimizado                   | üî¥ 0%  | 0%         | 0h / 1h     | N√£o      |
| Collision Overlay                | üî¥ 0%  | 0%         | 0h / 2h     | N√£o      |
| Zoom/Pan Suave                   | üî¥ 0%  | 0%         | 0h / 2-3h   | N√£o      |
| Hot-Reload Server                | üî¥ 0%  | 0%         | 0h / 3-4h   | ‚ö†Ô∏è Sim   |
| Hot-Reload Client                | üî¥ 0%  | 0%         | 0h / 1h     | ‚ö†Ô∏è Sim   |
| PropertyGrid Aprimorado          | üî¥ 0%  | 0%         | 0h / 3-4h   | N√£o      |
| Tutorial "Primeiro Mapa"         | üî¥ 0%  | 0%         | 0h / 2-3h   | N√£o      |
| Documenta√ß√£o de Atalhos          | üî¥ 0%  | 0%         | 0h / 1h     | N√£o      |
| Testes de Performance            | üî¥ 0%  | 0%         | 0h / 1-2h   | ‚ö†Ô∏è Sim   |
| Testes de Integra√ß√£o             | üî¥ 0%  | 0%         | 0h / 1-2h   | N√£o      |
| Polish Final                     | üî¥ 0%  | 0%         | 0h / 1h     | N√£o      |

**Total Geral:** 0% (0h / 20-25h)  
**Blockers Restantes:** 4

---

## üéØ Ordem de Implementa√ß√£o Recomendada

### **Sprint 1 (8-10h): Performance Core**
1. ‚úÖ OpenGL Moderno (VBOs/Shaders) - 8-10h
2. ‚úÖ Grid Otimizado - 1h

**Milestone:** Editor roda a 60 FPS com mapas grandes

### **Sprint 2 (6-8h): Usabilidade**
1. ‚úÖ Collision Overlay - 2h
2. ‚úÖ Zoom/Pan Suave - 2-3h
3. ‚úÖ PropertyGrid Aprimorado - 3-4h

**Milestone:** Editor √© intuitivo e produtivo

### **Sprint 3 (4-5h): Hot-Reload**
1. ‚úÖ Hot-Reload Server - 3-4h
2. ‚úÖ Hot-Reload Client - 1h

**Milestone:** Mudan√ßas aparecem no runtime instantaneamente

### **Sprint 4 (3-4h): Documenta√ß√£o**
1. ‚úÖ Tutorial "Primeiro Mapa" - 2-3h
2. ‚úÖ Documenta√ß√£o de Atalhos - 1h

**Milestone:** Usu√°rios conseguem aprender rapidamente

### **Sprint 5 (3-4h): Qualidade**
1. ‚úÖ Testes de Performance - 1-2h
2. ‚úÖ Testes de Integra√ß√£o - 1-2h
3. ‚úÖ Polish Final - 1h

**Milestone:** Release pronto para produ√ß√£o

---

## üö® Riscos e Mitiga√ß√µes

### **Risco 1: OpenGL Moderno Muito Complexo**
**Probabilidade:** M√©dia  
**Impacto:** Alto  
**Mitiga√ß√£o:**
- Come√ßar com shader simples (vertex + fragment b√°sicos)
- Usar bibliotecas helper (GLM, GLEW)
- Manter fallback para immediate mode se necess√°rio
- Priorizar funcionamento sobre otimiza√ß√£o prematura

### **Risco 2: Hot-Reload com Sockets Inst√°vel**
**Probabilidade:** M√©dia  
**Impacto:** M√©dio  
**Mitiga√ß√£o:**
- Usar Named Pipes no Windows (mais simples que sockets)
- Implementar timeout e reconex√£o autom√°tica
- Testar com m√∫ltiplos runtimes
- Adicionar op√ß√£o para desabilitar hot-reload

### **Risco 3: Performance N√£o Atinge 60 FPS**
**Probabilidade:** Baixa  
**Impacto:** Alto  
**Mitiga√ß√£o:**
- Implementar frustum culling
- Batch rendering eficiente
- Perfil com VTune ou similar
- Reduzir desenho de elementos invis√≠veis

### **Risco 4: Tempo Excede Estimativa**
**Probabilidade:** Alta  
**Impacto:** M√©dio  
**Mitiga√ß√£o:**
- Priorizar features cr√≠ticas (OpenGL, Hot-Reload)
- Features secund√°rias podem ficar para M1.2 se necess√°rio
- Timeboxing: limitar tempo por tarefa
- Revis√£o de progresso a cada sprint

---

## üìù Notas de Implementa√ß√£o

### **OpenGL Context Setup (wxGLCanvas)**
```cpp
// No construtor do GLCanvas
wxGLAttributes glAttrs;
glAttrs.PlatformDefaults().RGBA().DoubleBuffer().Depth(16).EndList();
m_glCanvas = new GLCanvas(this, glAttrs);

// No InitGL
SetCurrent(*m_glContext);
glewInit(); // Se usar GLEW
glEnable(GL_DEPTH_TEST);
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
```

### **Shader Loading Helper**
```cpp
GLuint LoadShaderFromFile(const char* path, GLenum shaderType) {
    std::ifstream file(path);
    std::string source((std::istreambuf_iterator<char>(file)),
                       std::istreambuf_iterator<char>());
    
    const char* sourceCStr = source.c_str();
    GLuint shader = glCreateShader(shaderType);
    glShaderSource(shader, 1, &sourceCStr, nullptr);
    glCompileShader(shader);
    
    // Check compile errors...
    
    return shader;
}
```

### **Hot-Reload Message Send (TCP Socket)**
```cpp
void HotReloadServer::NotifyMapChanged(const wxString& mapPath) {
    Message msg;
    msg.type = MSG_MAP_CHANGED;
    
    std::string pathUtf8 = mapPath.ToUTF8().data();
    msg.dataSize = pathUtf8.size();
    memcpy(msg.data, pathUtf8.c_str(), msg.dataSize);
    
    for (int clientSocket : m_clients) {
        send(clientSocket, (const char*)&msg, sizeof(msg), 0);
    }
}
```

---

## ‚úÖ Checklist Final para Release v0.3.0

### **Funcionalidades**
- [ ] OpenGL moderno implementado
- [ ] Performance >= 60 FPS com mapas 100x100
- [ ] Collision overlay funcional
- [ ] Zoom/Pan suave implementado
- [ ] Hot-reload funcionando (editor ‚Üí runtime < 100ms)
- [ ] PropertyGrid din√¢mico completo

### **Qualidade**
- [ ] Todos os testes passando (unit + integration + performance)
- [ ] Build limpo (0 warnings)
- [ ] Cobertura de c√≥digo >= 80%
- [ ] Sem memory leaks (verificado com sanitizers)

### **Documenta√ß√£o**
- [ ] Tutorial "Primeiro Mapa" completo
- [ ] SHORTCUTS.md criado
- [ ] ROADMAP.md atualizado
- [ ] CHANGELOG.md atualizado

### **Release**
- [ ] Merge de `feature/m1.1-polish` ‚Üí `main`
- [ ] Tag `v0.3.0` criada
- [ ] Release notes no GitHub
- [ ] Exemplo `first_map_tutorial` inclu√≠do

---

**√öltima Atualiza√ß√£o:** 03/11/2025 00:23  
**Respons√°vel:** Equipe Lumy  
**Pr√≥xima Revis√£o:** Ap√≥s Sprint 1 (OpenGL Moderno)
